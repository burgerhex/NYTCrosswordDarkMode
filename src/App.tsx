/* eslint-disable react-hooks/exhaustive-deps */
import React, {useEffect, useRef, useState} from 'react';
import './App.css';

// import {Button, Col, Container, Dropdown, Form, Row} from "react-bootstrap";

class ColorOptions {
  [key: string]: string; // allow name indexing
  name: string = "Default";
  // stuff on the page
  mainPageColor: string = "#ffffff";
  pageAccentColor: string = "#4083fb";
  pageTextColor: string = "#000000";
  clueBarBackgroundColor: string = "#dcefff";
  // stuff in the crossword
  cellColor: string = "#ffffff";
  cellTextColor: string = "#000000";
  blockCellColor: string = "#000000";
  selectedCellColor: string = "#ffda00";
  highlightedCellColor: string = "#a7d8ff";
  relatedCellColor: string = "#ffeca0";
}

const defaultColorOptions = new ColorOptions();
const darkModeOptions = {
  name: "Dark Mode",
  mainPageColor: "#121212",
  pageAccentColor: "#9b40ff",
  pageTextColor: "#ededed",
  clueBarBackgroundColor: "#2c0d52",
  cellColor: "#121212",
  cellTextColor: "#ededed",
  blockCellColor: "#d0d0d0",
  selectedCellColor: "#712ec1",
  highlightedCellColor: "#3c146c",
  relatedCellColor: "#394f32",
};
// these were generated by gemini and slightly adjusted by me
const fallThemeOptions = {
  name: "Fall",
  mainPageColor: "#f5f0e0",
  pageAccentColor: "#b22222",
  pageTextColor: "#000000",
  clueBarBackgroundColor: "#ffe4b5",
  cellColor: "#f5f0e0",
  cellTextColor: "#000000",
  blockCellColor: "#800000",
  selectedCellColor: "#ffbb00",
  highlightedCellColor: "#ffd700",
  relatedCellColor: "#ffa500",
};
const winterThemeOptions = {
  name: "Winter",
  mainPageColor: "#f0f0ff",
  pageAccentColor: "#007bff",
  pageTextColor: "#000000",
  clueBarBackgroundColor: "#d9d9ff",
  cellColor: "#f0f0ff",
  cellTextColor: "#000000",
  blockCellColor: "#000080",
  selectedCellColor: "#00ffff",
  highlightedCellColor: "#80dfff",
  relatedCellColor: "#00bfff",
};
const springThemeOptions = {
  name: "Spring",
  mainPageColor: "#f2f5f0",
  pageAccentColor: "#008000",
  pageTextColor: "#000000",
  clueBarBackgroundColor: "#d9ffd9",
  cellColor: "#f2f5f0",
  cellTextColor: "#000000",
  blockCellColor: "#009600",
  selectedCellColor: "#90ee90",
  highlightedCellColor: "#adffad",
  relatedCellColor: "#c4ff57",
};
const summerThemeOptions = {
  name: "Summer",
  mainPageColor: "#f8f8e0",
  pageAccentColor: "#ff8c00",
  pageTextColor: "#000000",
  clueBarBackgroundColor: "#ffe4b5",
  cellColor: "#f8f8e0",
  cellTextColor: "#000000",
  blockCellColor: "#a8a800",
  selectedCellColor: "#ffff00",
  highlightedCellColor: "#ffff80",
  relatedCellColor: "#ff7f50",
};
const allPresets = [defaultColorOptions, darkModeOptions,
  fallThemeOptions, winterThemeOptions, summerThemeOptions, springThemeOptions,
];
const nameToPreset = Object.fromEntries(allPresets.map(preset => [preset.name, preset]));

function saveOptionsToStorage(presetName: string, colors: ColorOptions, customPreset: ColorOptions) {
  const options = {options: {presetName: presetName, colors: colors, customPreset: customPreset}};
  chrome.storage.sync.set(options, () => {
    console.log("Options SAVED to storage:", options);
  });
}

function App() {
  const [presetName, setPresetName] = useState("Default");
  const [colorOptions, setColorOptions] = useState(defaultColorOptions);
  const [customPreset, setCustomPreset] = useState(defaultColorOptions);

  const [isSavedTextVisible, setIsSavedTextVisible] = useState(false);

  const loading = useRef(true);
  const ignoreNextUpdate = useRef(false);

  // get initial settings from storage, if they're there
  useEffect(() => {
    chrome.storage.sync.get(["options"], (result) => {
      let storedPresetName = result.options?.presetName;
      setPresetName(storedPresetName ?? presetName);

      let storedColors = result.options?.colors;
      setColorOptions(storedColors ?? defaultColorOptions);

      let storedPreset = result.options?.customPreset;
      let newPreset = new ColorOptions();
      for (const key in newPreset) {
        newPreset[key] = storedPreset[key] ?? customPreset[key];
      }
      setCustomPreset(newPreset);

      loading.current = false;
    });
  }, []);

  const timer = useRef(setTimeout(() => {
  }));

  // if custom preset is changed, immediately update settings
  useEffect(() => {
    if (loading.current) {
      console.log("still loading user options, skipping storage update");
      return;
    }

    clearTimeout(timer.current);

    saveOptionsToStorage(presetName, colorOptions, customPreset);
  }, [customPreset]);

  // if other settings are changed, "debounce" for 1s
  useEffect(() => {
    if (loading.current) {
      console.log("still loading user options, skipping storage update");
      return;
    }
    if (ignoreNextUpdate.current) {
      console.log("ignoring one colorOptions update");
      ignoreNextUpdate.current = false;
      return;
    }

    clearTimeout(timer.current);

    timer.current = setTimeout(() => {
      saveOptionsToStorage(presetName, colorOptions, customPreset);
    }, 1000);
  }, [colorOptions]);

  function handlePresetChange(presetName: string) {
    ignoreNextUpdate.current = true;
    const colors = presetName === "Custom Preset" ? customPreset : nameToPreset[presetName];
    setPresetName(presetName);
    setColorOptions(colors);
    saveOptionsToStorage(presetName, colors, customPreset);
  }

  function handleCustomPresetSave() {
    setIsSavedTextVisible(false);
    // hack to reset animation
    setTimeout(() => setIsSavedTextVisible(true), 0);
    setCustomPreset(colorOptions);
  }

  return (
    <div className="Popup">
      <div className="InnerPopup">
        <img className="PopupLogo" src="../images/icon-128.png" alt="Extension logo"/>
        <h1 className="PopupTitle">NYT Crossword Dark Mode Options</h1>

        <br/>

        <label className="PopupLabel PresetLabel">Preset:</label>
        <select value={presetName} onChange={(e) => handlePresetChange(e.target.value)}>
          {allPresets.map(preset =>
            <option id={preset.name}>{preset.name}</option>
          )}
          <option id={"Custom"}>Custom Preset</option>
        </select>


        <div className="PopupColumns">

          <div className="PopupLeftColumn">

            <span className="PopupColumnLabel">Crossword Colors</span>

            <div className="PopupOption">
              <input type="color" value={colorOptions.cellColor}
                     onChange={(e) => setColorOptions({...colorOptions, cellColor: e.target.value})}/>
              <span className="PopupColorLabel">Normal Cell Color</span>
            </div>

            <div className="PopupOption">
              <input type="color" value={colorOptions.cellTextColor}
                     onChange={(e) => setColorOptions({...colorOptions, cellTextColor: e.target.value})}/>
              <span className="PopupColorLabel">Cell Text Color</span>
            </div>

            <div className="PopupOption">
              <input type="color" value={colorOptions.blockCellColor}
                     onChange={(e) => setColorOptions({...colorOptions, blockCellColor: e.target.value})}/>
              <span className="PopupColorLabel">Block Cell Color</span>
            </div>

            <div className="PopupOption">
              <input type="color" value={colorOptions.selectedCellColor}
                     onChange={(e) => setColorOptions({...colorOptions, selectedCellColor: e.target.value})}/>
              <span className="PopupColorLabel">Selected Cell Color</span>
            </div>

            <div className="PopupOption">
              <input type="color" value={colorOptions.highlightedCellColor}
                     onChange={(e) => setColorOptions({...colorOptions, highlightedCellColor: e.target.value})}/>
              <span className="PopupColorLabel">Highlighted Cell Color</span>
            </div>

            <div className="PopupOption">
              <input type="color" value={colorOptions.relatedCellColor}
                     onChange={(e) => setColorOptions({...colorOptions, relatedCellColor: e.target.value})}/>
              <span className="PopupColorLabel">Related Color</span>
            </div>
          </div>


          <div className="PopupRightColumn">
            <span className="PopupColumnLabel">Page Colors</span>

            <div className="PopupOption">
              <input type="color" value={colorOptions.mainPageColor}
                     onChange={(e) => setColorOptions({...colorOptions, mainPageColor: e.target.value})}/>
              <span className="PopupColorLabel">Main Page Color</span>
            </div>

            <div className="PopupOption">
              <input type="color" value={colorOptions.pageAccentColor}
                     onChange={(e) => setColorOptions({...colorOptions, pageAccentColor: e.target.value})}/>
              <span className="PopupColorLabel">Page Accent Color</span>
            </div>

            <div className="PopupOption">
              <input type="color" value={colorOptions.pageTextColor}
                     onChange={(e) => setColorOptions({...colorOptions, pageTextColor: e.target.value})}/>
              <span className="PopupColorLabel">Page Text Color</span>
            </div>

            <div className="PopupOption">
              <input type="color" value={colorOptions.clueBarBackgroundColor}
                     onChange={(e) => setColorOptions({...colorOptions, clueBarBackgroundColor: e.target.value})}/>
              <span className="PopupColorLabel">Clue Bar Background Color</span>
            </div>
          </div>

        </div>


        <div className="PopupSave">
          <button onClick={handleCustomPresetSave}>Save to custom preset</button>
          <span className={`PopupApplied ${isSavedTextVisible ? "visible" : ""}`}>Saved!</span>
        </div>

        <span className="PopupLabel">Changed options will be applied after 1 second.</span>
        <span className="PopupLabel PopupHelpLabel">Problem?&nbsp;
        <a target="_blank" href="https://github.com/burgerhex/NYTCrosswordDarkMode/issues/new" rel="noreferrer">
            Report here!
          </a>
        </span>
      </div>
    </div>
  );
}

export default App;
